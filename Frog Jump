Problem Link: https://www.codingninjas.com/studio/problems/frog-jump_3621012?utm_source=striver&utm_medium=website&utm_campaign=a_zcoursetuf&leftPanelTab=3

Approach
Memoization:

Recursion:

recurisvely start from index 0 to last index find value if one step is taken and if two steps are taken at a time.
Now take minimum of both.
think of base cases as if current index is equal to size of  array - 1 and what if current index exceeds the size of array.

Code:

int frogjump_helper(int i, vector<int>&heights,vector<int>&dp){
    if(i == heights.size()-1) //if current index is equal to size of array - 1
        return 0;
    if(i > heights.size()-1) //current index exceeds the size of array -1 
        return INT_MAX;
    if(dp[i] != -1)    // If dp[i] is not -1 then return dp[i] as it avoids multiple subproblems and improve time complexity
        return dp[i];
    int first_step = frogjump_helper(i+1, heights, dp) + abs(heights[i] - heights[i+1]);
    int two_step = (i+2 < heights.size()) ? frogjump_helper(i+2, heights, dp) + std::abs(heights[i] - heights[i+2]) : INT_MAX;

    return dp[i] = min(first_step, two_step);
}
int frogJump(int n, vector<int> &heights)
{
    vector<int> dp(n, -1); // Initialize dp vector with -1
    return frogjump_helper(0,heights,dp);
}
